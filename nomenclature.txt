* System Token:
Set of information stored by the Server regarding a specific user login session.
In Caronte (server) this is a database table containing login data (timestamp, token counter, last use, etc).

* User Token:
Ultra-Redundant one-way hash of some or all the information within a system token.
Required to generate valid Tickets.
In Caronte (server) this is the result of hashing some random data and the token's timestamp.

* Ticket
Set of information used to identify and authenticate a user.
There are several types of tickets depending on who creates them, how they are created and what they are used for.

* Ticket-Granting-Ticket (TGT)
Ticket created by Caronte (server).
Used by the user to correctly authenticate Caronte and generate Service-Granting-Tickets.
In Caronte the TGT contains a newly created user token and Caronte identification details, all encrypted with the user's derived key.

* Service-Granting-Ticket (SGT)
Ticket created by the user based on the information (user token) found inside the TGT.
It identifies and authenticates the user against Caronte.
In Caronte (client), the SGT contains the user token, user IV, user email and token counter all encrypted using the user's derived key and a plain user ID (currently using user's IV used to derive passwords).
The token counter in an SGT must be equal to the token counter in Caronte server + 1.
The user token must match the current valid system token.
User IV and email must match with the user's database fields.

* Key-Granting-Ticket (KGT)
Ticket created by a user B containing the SGT of another user A attempting to access a resource from B.
This ticket identifies both user B (service provider) and user A (service consumer).
It is used to establish a secure connection between users A and B.
In Caronte (client), the KGT must contain a plain ID for user B and the SGT from user A encrypted using the key derived from user B's password.

* Ultra-Redundant Hash
Hash function where the output data contains more information than the input data without revealing the original data (not reversible).
Mathematically: size(hash(msg)) > size(msg)
This effectively eliminates any possible collision as there's an infinite amount of possible outputs.
In Caronte, an ultra-redundant hash is calculated as:
ultrahash(msg) = AES_encrypt(data=msg+padding, key=SHA256(msg), IV=MD5(msg))
The term "ultra-redundant" refers to the fact that the original message is still fully contained within the Hash, but extra data - also dependant on the original message - is appended.
Since the size of the output is always bigger than the input, collisions are fully eliminated.
Caronte uses this technique to hash user emails and passwords without risking a collision.

